import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/syntactic_entity.dart';
import 'package:analyzer/dart/ast/token.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/type_visitor.dart';
import 'package:build/build.dart';
import 'package:collection/collection.dart';

import '../resolver/component.dart';
import '../resolver/dart.dart';
import '../resolver/flow.dart';
import '../resolver/preparation.dart';
import '../resolver/reactive_dom.dart';
import '../resolver/resolver.dart';
import '../utils/dart.dart';
import 'imports.dart';
import 'options.dart';
import 'ssr/node_to_text.dart';
import 'tree.dart';

const _prefix = r'_$';
const _parentField = '${_prefix}parent';

class Generator {
  final GenerationScope libraryScope = GenerationScope();
  late final ImportsTracker imports;

  final GenerationOptions options;

  final PrepareResult prepareResult;
  final ResolvedComponent component;

  final Map<BaseZapVariable, String> _varNames = {};
  final Map<ReactiveNode, String> _nodeNames = {};
  final Map<FunctionElement, String> _functionNames = {};
  final Map<Object, String> _miscNames = {};

  String get zapPrefix => imports.zapImport;
  String get htmlPrefix => imports.dartHtmlImport;

  Generator(this.component, this.prepareResult, this.options, AssetId output) {
    imports = ImportsTracker(libraryScope.inner(), output);
  }

  String _nameForVar(BaseZapVariable variable) {
    return _varNames.putIfAbsent(variable, () {
      return '${_prefix}v${_varNames.length}';
    });
  }

  String _nameForNode(ReactiveNode node) {
    return _nodeNames.putIfAbsent(node, () {
      return '${_prefix}n${_nodeNames.length}';
    });
  }

  String _nameForFunction(FunctionElement fun) {
    return _functionNames.putIfAbsent(fun, () => '${_prefix}fun_${fun.name}');
  }

  String _nameForMisc(Object key) {
    return _miscNames.putIfAbsent(
      key,
      () => '_${_prefix}t${_miscNames.length}',
    );
  }

  void write() {
    imports.imports.writeln('// Generated by zap_dev, do not edit!');
    _writeComponent(component.component);

    // Write top-level members declared outside of the component (in a
    // `<script context="module">` scope).
    for (final declaration in component.declarationsFromModuleScope) {
      libraryScope.leaf().write(
        _DartSourceRewriter.patchDartReferences(
          dartCode: declaration,
          generator: this,
          patchSelf: false, // Not in a component, can't use `self`.
        ),
      );
    }

    imports.ensureImportsAreWritten();
  }

  void _writeComponent(ComponentOrSubcomponent component) {
    _ComponentOrSubcomponentWriter writer;
    final scope = libraryScope.inner(ScopeLevel.$class);
    final opt = this.component.optimization.forComponent(component);

    if (component is Component) {
      writer = _ComponentWriter(
        component,
        this.component.componentName,
        this,
        scope,
      );
    } else {
      // Instead of writing a full class, we can write this fragment as a static
      // node.
      if (opt.isCompileTimeConstant) {
        _writeConstantComponent(component as ResolvedSubComponent);
        return;
      }

      writer = _SubComponentWriter(
        component as ResolvedSubComponent,
        this,
        scope,
      );
    }

    writer.write();

    component.children.forEach(_writeComponent);
  }

  void _writeConstantComponent(ResolvedSubComponent component) {
    final name = _nameForMisc(component);
    final writer = NodeWriter();
    component.fragment.rootNodes.forEach(writer.writeNode);

    libraryScope.leaf().write(
      'final $name = $zapPrefix.HtmlTag'
      '(${dartStringLiteral(writer.buffer.toString())});',
    );
  }
}

abstract class _ComponentOrSubcomponentWriter {
  final Generator generator;
  final GenerationScope classScope;
  final StringBuffer buffer;

  ComponentOrSubcomponent get component;

  _ComponentOrSubcomponentWriter(this.generator, this.classScope)
    : buffer = classScope.leaf();

  bool _rendersSubcomponents(ReactiveNode node) =>
      node is SubComponent || node is ReactiveBlock || node is MountSlot;

  bool _isZapFragment(ReactiveNode node) =>
      _rendersSubcomponents(node) || node is ReactiveRawHtml;

  bool _passDownUpdates(ReactiveNode node) =>
      _isZapFragment(node) && node is! SubComponent;

  bool _isInitializedLater(ReactiveNode node) => _rendersSubcomponents(node);

  void write();

  String get componentThis {
    if (component is Component) {
      // Root component
      return 'this';
    } else {
      return _DartSourceRewriter(
        generator,
        component.scope,
        0,
        '',
        true,
        const {},
      )._prefixFor(generator.component.component.scope, trailingDot: false);
    }
  }

  String get atOverride => '@${prefixIdentifier('override')}';

  String prefixIdentifier(String identifier, [String from = 'dart:core']) {
    final uri = Uri.parse(from);
    return '${generator.imports.importForUri(uri)}.$identifier';
  }

  String dartTypeToString(DartType type) {
    final buffer = StringBuffer();

    type.accept(_DartTypeWriter(generator, buffer));
    return buffer.toString();
  }

  String? dartTypeName(ReactiveNode node) {
    final htmlPrefix = generator.imports.dartHtmlImport;
    final zapPrefix = generator.imports.zapImport;

    if (node is ReactiveElement) {
      final known = node.knownElement;

      return known != null
          ? '$htmlPrefix.${known.className}'
          : '$htmlPrefix.Element';
    } else if (node is ReactiveText || node is ConstantText) {
      return '$htmlPrefix.Text';
    } else if (node is ReactiveRawHtml) {
      return '$zapPrefix.HtmlTag';
    } else if (node is SubComponent) {
      // The import tracker will rewrite imports from the intermediate library
      // to the final `.zap.dart` file.
      final prefix = generator.imports.importForLibrary(
        node.component.temporaryApiClass.library,
      );
      return '$prefix.${node.component.temporaryApiClass.name}';
    } else if (node is DynamicSubComponent) {
      return '$zapPrefix.DynamicComponent';
    } else if (node is ReactiveIf) {
      return '$zapPrefix.IfBlock';
    } else if (node is ReactiveFor) {
      final innerType = dartTypeToString(node.elementType);
      return '$zapPrefix.ForBlock<$innerType>';
    } else if (node is ReactiveAsyncBlock) {
      final innerType = dartTypeToString(node.type);

      return node.isStream
          ? '$zapPrefix.StreamBlock<$innerType>'
          : '$zapPrefix.FutureBlock<$innerType>';
    } else if (node is MountSlot) {
      return '$zapPrefix.Slot';
    } else {
      return null;
    }
  }

  String _slotVariable(String? slot) {
    return '\$slot_${slot ?? ''}';
  }

  bool _componentIsOptimizedAway(ComponentOrSubcomponent component) {
    final opt = generator.component.optimization.forComponent(component);
    return opt.isCompileTimeConstant;
  }

  String _createSubFragment(
    ComponentOrSubcomponent subComponent,
    String constructorArguments,
  ) {
    final name = generator._nameForMisc(subComponent);

    if (_componentIsOptimizedAway(subComponent)) {
      // We'll write a top-level field for this constant fragment.
      return name;
    } else {
      return '$name($constructorArguments)';
    }
  }

  String _statementsToChangeVariable(
    BaseZapVariable variable,
    String expression,
  ) {
    final prefix = _DartSourceRewriter(
      generator,
      component.scope,
      0,
      '',
      true,
      const {},
    )._prefixFor(variable.scope);
    final variableName = generator._nameForVar(variable);

    final result = StringBuffer();
    if (variable.needsUpdateTracking) {
      result.writeln('$prefix\$invalidate(${variable.updateBitmask});');
    }

    result.writeln('$prefix$variableName = $expression;');
    return result.toString();
  }

  String referenceExpression(ResolvedDartExpression expression) {
    final ownScope = component.scope;
    final expressionScope = expression.scope;

    final prefix = _DartSourceRewriter(
      generator,
      ownScope,
      0,
      '',
      true,
      const {},
    )._prefixFor(expressionScope);

    return '$prefix${generator._nameForMisc(expression)}';
  }

  /// Writes
  ///
  ///  - DOM nodes and zap fragments
  ///  - getters to evaluate expressions used in the component
  void writeCommonInstanceFields() {
    // Write instance fields storing DOM nodes or zap block helpers
    for (final node in component.fragment.allNodes) {
      final name = generator._nameForNode(node);
      final isInitializedLater = _isInitializedLater(node);

      if (isInitializedLater) {
        buffer.write('late ');
      }

      buffer
        ..write('final ')
        ..write(dartTypeName(node))
        ..write(' ')
        ..write(name);

      if (!isInitializedLater) {
        buffer.write(' = ');
        createNode(node);
      }

      buffer.writeln(';');

      if (node is ReactiveIf) {
        // Write a function used to evaluate the condition for an if block
        final name = generator._nameForMisc(node);
        buffer.writeln('${prefixIdentifier('int')} $name() {');
        for (var i = 0; i < node.conditions.length; i++) {
          if (i != 0) {
            buffer.write('else ');
          }
          buffer
            ..writeln('if (${referenceExpression(node.conditions[i])}) {')
            ..writeln('  return $i;')
            ..writeln('}');
        }
        buffer.writeln('else { return ${node.conditions.length}; }}');
      }
    }

    // Create getters for expressions, avoiding duplicate code when an
    // expression is used more than once.
    for (final usedExpression in component.scope.usedDartExpressions) {
      final name = generator._nameForMisc(usedExpression);

      buffer
        ..write(dartTypeToString(usedExpression.staticType))
        ..write(' get $name => ');
      writeDartWithPatchedReferences(
        usedExpression.expression,
        // When this expression uses `watch(<x>)`, refer to the getter we'll
        // generate for `<x>` instead of duplicating the source code.
        watchedExpressions: {
          for (final expr in usedExpression.watched)
            expr.expression.expression: expr,
        },
      );
      buffer.writeln(';');
    }

    // Similarly, create methods for side-effect actions to avoid emitting the
    // same code in the constructor and in `update()`.
    for (final flow in component.flows) {
      final action = flow.action;
      if (action is SideEffect) {
        final name = generator._nameForMisc(action);

        buffer.write('void $name() {');
        writeDartWithPatchedReferences(action.statement);
        buffer.write(';}');
      }

      // Mutable stream subscriptions are stored as instance variables too
      if (!flow.isOneOffAction && action is RegisterEventHandler) {
        final dartAsync = generator.imports.importForUri(
          Uri.parse('dart:async'),
        );
        final type = dartTypeToString(action.handler.dartEventType);

        buffer
          ..write('late ')
          ..write('$dartAsync.StreamSubscription<$type> ')
          ..write(generator._nameForMisc(action.handler))
          ..writeln(';');
      }
    }
  }

  void writeCreateMethod() {
    final name = component is Component ? 'createInternal' : 'create';
    final prefix = generator.htmlPrefix;

    buffer
      ..writeln(atOverride)
      ..writeln('void $name($prefix.Element target, [$prefix.Node? anchor]) {');

    // Create subcomponents. They require evaluating Dart expressions, so we
    // can't do this earlier.
    for (final node in component.fragment.allNodes) {
      if (_isInitializedLater(node)) {
        buffer
          ..write(generator._nameForNode(node))
          ..write(' = ');
        createNode(node);
        buffer.writeln(';');
      }

      // Implement `bind:this` binders by assigning nodes to their target
      // variables now.
      if (node is ReactiveElement) {
        for (final binder in node.binders) {
          final target = binder.target;
          final prefix = _DartSourceRewriter(
            generator,
            component.scope,
            0,
            '',
            true,
            const {},
          )._prefixFor(target.scope);
          final variableName = generator._nameForVar(target);
          final nodeName = generator._nameForNode(node);

          if (binder is BindThis) {
            buffer.write(_statementsToChangeVariable(target, nodeName));
          } else if (binder is BindProperty) {
            final callback =
                '''
                (value) {
                  if (value != $prefix$variableName) {
                    ${_statementsToChangeVariable(target, 'value')}
                  }
                }
            ''';

            switch (binder.specialMode) {
              case SpecialBindingMode.inputValue:
                final import = generator.imports.dartHtmlImport;
                buffer.write(
                  '$import.GlobalEventHandlers.inputEvent'
                  '.forElement($nodeName)'
                  '.map((e) => $nodeName.value)'
                  '.transform(lifecycle())'
                  '.listen($callback);',
                );
                break;
              case null:
                buffer
                  ..write(nodeName)
                  ..write('.watchAttribute(')
                  ..write(dartStringLiteral(binder.attribute))
                  ..write(')')
                  ..write('.transform(lifecycle())')
                  ..writeln('.listen($callback);');
                break;
            }
          }
        }
      }
    }

    // In the create method, we set the initial value of Dart expressions and
    // register event handlers.
    for (final flow in component.flows) {
      if (flow.isOneOffAction) {
        writeFlowAction(flow, isInCreate: true);
      }
    }

    void writeAdd(Iterable<ReactiveNode> nodes, String target, String? anchor) {
      for (final node in nodes) {
        final name = generator._nameForNode(node);

        if (_isZapFragment(node)) {
          buffer
            ..write(name)
            ..writeln('.create($target, $anchor);');
          continue;
        } else if (anchor == null) {
          // Write an append call
          buffer.writeln('$target.append($name);');
        } else {
          // Use insertBefore then
          buffer.writeln('$target.insertBefore($name, $anchor);');
        }

        // Mount child nodes as well
        writeAdd(node.children, name, null);
      }
    }

    /// Also add nodes into the document now.
    writeAdd(component.fragment.rootNodes, 'target', 'anchor');
    buffer.writeln('}');
  }

  void writeRemoveMethod() {
    final name = component is Component ? 'remove' : 'destroy';

    buffer
      ..writeln(atOverride)
      ..writeln('void $name() {');

    for (final rootNode in component.fragment.rootNodes) {
      buffer.write(generator._nameForNode(rootNode));

      if (_isZapFragment(rootNode)) {
        // use .destroy() to unmount zap components
        buffer.write('.destroy();');
      } else {
        // and .remove() to unmount `dart:html` elements.
        buffer.write('.remove();');
      }
    }

    // We can unmount the root nodes to remove this component from the DOM tree.
    // However, we should still explicitly destroy() child components so that
    // they can clean up resources.
    for (final node in component.fragment.rootNodes.expand(
      (node) => node.allDescendants,
    )) {
      if (_rendersSubcomponents(node)) {
        buffer.write(generator._nameForNode(node));

        buffer.write('.destroy();');
      }
    }

    buffer.writeln('}');
  }

  void writeUpdateMethod() {
    buffer
      ..writeln(atOverride)
      ..writeln('void update(${prefixIdentifier('int')} delta) {');

    for (final flow in component.flows) {
      if (!flow.isOneOffAction) {
        buffer
          ..write('if (delta & ')
          ..write(flow.bitmask)
          ..writeln(' != 0) {');
        writeFlowAction(flow);
        buffer.writeln('}');
      }
    }

    // Some nodes manage subcomponents and need to be updated as well
    for (final node in component.fragment.allNodes.where(_passDownUpdates)) {
      final name = generator._nameForNode(node);
      buffer.writeln('$name.update(delta);');
    }

    buffer.writeln('}');
  }

  void writeFlowAction(Flow flow, {bool isInCreate = false}) {
    final action = flow.action;

    if (action is SideEffect) {
      final implementingFunction = generator._nameForMisc(action);
      buffer.writeln('$implementingFunction();');
    } else if (action is ChangeText) {
      writeSetText(action.text);
    } else if (action is RegisterEventHandler) {
      final handler = action.handler;
      if (flow.isOneOffAction) {
        // Just register the event handler, it won't be changed later!
        registerEventHandler(handler);
      } else {
        if (isInCreate) {
          // We need to store the result of listening in a stream subscription
          // so that the event handler can be changed later.
          buffer
            ..write(generator._nameForMisc(handler))
            ..write(' = ');
          registerEventHandler(handler);
        } else {
          // Just change the onData callback of the stream subscription now
          buffer
            ..write(generator._nameForMisc(handler))
            ..write('.onData(');
          callbackForEventHandler(handler);
          buffer.writeln(');');
        }
      }
    } else if (action is ApplyAttribute) {
      final attribute = action.element.attributes[action.name]!;
      final nodeName = generator._nameForNode(action.element);
      buffer.write(nodeName);

      switch (attribute.mode) {
        case AttributeMode.setValue:
          if (action.name == 'class' &&
              generator.component.cssClassName != null) {
            // Make sure the scoped css class is still included when setting the
            // class attribute
            buffer
              ..write('.setClassAttribute(')
              ..write(dartStringLiteral(generator.component.cssClassName!))
              ..write(', ')
              ..write(referenceExpression(attribute.backingExpression))
              ..write('.toString());');
          } else {
            // Just emit node.attributes[key] = value.toString()
            buffer
              ..write(".attributes['")
              ..write(action.name)
              ..write("'] = ")
              ..write(referenceExpression(attribute.backingExpression))
              ..write('.toString();');
          }

          break;
        case AttributeMode.addIfTrue:
          // Emit node.applyBooleanAttribute(key, value)
          buffer
            ..write('.applyBooleanAttribute(')
            ..write(dartStringLiteral(action.name))
            ..write(',')
            ..write(referenceExpression(attribute.backingExpression))
            ..write(');');
          break;
        case AttributeMode.setIfNotNullClearOtherwise:
          buffer
            ..write('.applyAttributeIfNotNull(')
            ..write(dartStringLiteral(action.name))
            ..write(',')
            ..write(referenceExpression(attribute.backingExpression))
            ..write(');');
          break;
      }
    } else if (action is ChangePropertyOfSubcomponent) {
      final target = generator._nameForNode(action.subcomponent);
      final expr = action.subcomponent.expressions[action.property]!;

      buffer.write(
        '$target.${action.property} = ${referenceExpression(expr)};',
      );
    } else if (action is UpdateWatchable) {
      final expr = referenceExpression(action.watched.expression);
      buffer.writeln(
        '\$watchImpl($expr, ${action.watched.updateSlot!}); // track update',
      );
    } else if (action is ReEvaluateVariableWithWatchInitializer) {
      final setter = generator._nameForVar(action.variable);
      final expression = referenceExpression(action.variable.initializer!);

      buffer.write('$setter = $expression;');
      if (action.variable.needsUpdateTracking) {
        buffer.write(
          _DartSourceRewriter(
            generator,
            component.scope,
            0,
            '',
            false,
            const {},
          ).invalidateExpression('${action.variable.updateBitmask}'),
        );
      }
    } else if (action is UpdateBlockExpression) {
      final block = action.block;
      final nodeName = generator._nameForNode(action.block);

      if (block is ReactiveIf) {
        final nameOfBranchFunction = generator._nameForMisc(block);

        buffer
          ..write(nodeName)
          ..write('.reEvaluate($nameOfBranchFunction());');
      } else if (block is ReactiveAsyncBlock) {
        final nodeName = generator._nameForNode(block);

        final setter = block.isStream ? 'stream' : 'future';
        final prefix = generator.zapPrefix;
        final wrapper = block.isStream
            ? '$prefix.\$safeStream'
            : '$prefix.\$safeFuture';
        final type = dartTypeToString(block.type);

        buffer
          ..write('$nodeName.$setter = $wrapper<$type>(() => ')
          ..write(referenceExpression(block.expression))
          ..write(');');
      } else if (block is ReactiveFor) {
        final nodeName = generator._nameForNode(block);

        buffer
          ..write('$nodeName.data = ')
          ..write(referenceExpression(block.expression))
          ..write(';');
      } else if (block is ReactiveKeyBlock) {
        buffer
          ..write('$nodeName.value = ')
          ..write(referenceExpression(block.expression))
          ..write(';');
      } else if (block is ReactiveRawHtml) {
        buffer
          ..write('$nodeName.rawHtml = ')
          ..write(referenceExpression(block.expression));

        if (block.needsToString) {
          buffer.write('.toString()');
        }
        buffer.write(';');
      } else if (block is DynamicSubComponent) {
        buffer
          ..write('$nodeName.component = ')
          ..write(referenceExpression(block.expression))
          ..write(';');
      } else {
        throw ArgumentError('Unknown target for $action: ${action.block}');
      }
    }
  }

  void registerEventHandler(EventHandler handler) {
    final knownEvent = handler.knownType;
    final parent = handler.parent;
    final node = generator._nameForNode(parent);

    void writeStreamToListenTo() {
      // Write the `Stream` expression for this event handler.
      if (parent is SubComponent) {
        final type = dartTypeToString(handler.dartEventType);
        buffer.write(
          '$node.componentEvents<$type>'
          '(${dartStringLiteral(handler.event)})',
        );
      } else {
        buffer.write('${generator.imports.dartHtmlImport}.');

        if (knownEvent != null) {
          buffer.write(knownEvent.providerExpression);
        } else {
          buffer.write("const EventStreamProvider('${handler.event}')");
        }

        buffer.write('.forElement($node');
        if (handler.isCapturing) {
          buffer.write(', useCapture = true');
        }
        buffer.write(')');
      }

      if (handler.modifier.isNotEmpty) {
        // Transform the event stream to account for the modifiers.
        buffer.write('.withModifiers(');

        for (final modifier in handler.modifier) {
          switch (modifier) {
            case EventModifier.preventDefault:
              buffer.write('preventDefault: true,');
              break;
            case EventModifier.stopPropagation:
              buffer.write('stopPropagation: true,');
              break;
            case EventModifier.passive:
              buffer.write('passive: true,');
              break;
            case EventModifier.nonpassive:
              buffer.write('passive: false,');
              break;
            case EventModifier.once:
              buffer.write('once: true,');
              break;
            case EventModifier.self:
              buffer.write('onlySelf: true,');
              break;
            case EventModifier.trusted:
              buffer.write('onlyTrusted: true,');
              break;
            case EventModifier.capture:
            // Handled by useCapture: true above
          }
        }

        buffer.write(')');
      }
    }

    if (handler.isForwarding) {
      buffer.write('$componentThis.forwardEvents(');
      writeStreamToListenTo();
      buffer.write(');');
    } else {
      writeStreamToListenTo();
      buffer.write('.listen(');
      callbackForEventHandler(handler);
      buffer.write(');');
    }
  }

  void callbackForEventHandler(EventHandler handler) {
    final listener = handler.listener!;

    if (handler.isNoArgsListener) {
      // The handler does not take any arguments, so we have to wrap it in a
      // function that does.
      buffer
        ..write('(_) {(')
        ..write(referenceExpression(listener))
        ..write(')();}');
    } else {
      // A tear-off will do
      buffer.write(referenceExpression(listener));
    }
  }

  void createNode(ReactiveNode node) {
    final htmlPrefix = generator.htmlPrefix;
    final zapPrefix = generator.zapPrefix;

    if (node is ReactiveElement) {
      final known = node.knownElement;

      if (known != null) {
        final type = '$htmlPrefix.${known.className}';

        if (known.instantiable) {
          // Use a direct constructor provided by the Dart SDK
          buffer.write(type);
          if (known.constructorName.isNotEmpty) {
            buffer.write('.${known.constructorName}');
          }

          buffer.write('()');
        } else {
          // Use the newElement helper method from zap
          buffer.write(
            '$zapPrefix.newElement<$type>(${dartStringLiteral(node.tagName)})',
          );
        }
      } else {
        buffer.write("$htmlPrefix.Element.tag('${node.tagName}')");
      }

      final className = generator.component.cssClassName;
      if (className != null) {
        buffer.write("..addComponentClass('$className')");
      }
    } else if (node is ReactiveText) {
      buffer.write("$htmlPrefix.Text('')");
    } else if (node is ConstantText) {
      buffer.write("$htmlPrefix.Text(${dartStringLiteral(node.text)})");
    } else if (node is ReactiveRawHtml) {
      buffer.write('$zapPrefix.HtmlTag()');
    } else if (node is SubComponent) {
      final typeName = dartTypeName(node);

      void instantiateComponent() {
        buffer.write('$typeName(');

        // Write properties passed down to the component.
        for (final property in node.component.parameters) {
          final name = property.key;
          final actualValue = node.expressions[name];

          if (actualValue == null) {
            buffer.write('null');
          } else {
            // Wrap values in a ZapValue to distinguish between set and absent
            // parameters.
            buffer
              ..write('$zapPrefix.ZapValue(')
              ..write(referenceExpression(actualValue))
              ..write(')');
          }

          buffer.write(',');
        }

        // Also write slots passed down.
        for (final slot in node.component.slotNames) {
          final child = slot == null ? node.defaultSlot : node.slots[slot];

          if (child == null) {
            buffer.write('null');
          } else {
            buffer.write(
              '() => ${_createSubFragment(child.owningComponent!, 'this')}',
            );
          }

          buffer.write(',');
        }

        buffer.writeln(')');
      }

      final component = this.component;
      if (component is ResolvedSubComponent && component.isMountedInSlot) {
        // The slot owner will take care of assigning the right parent context.
        instantiateComponent();
      } else {
        buffer
          ..write(componentThis)
          ..write('.\$createChildComponent<$typeName>(() => ');
        instantiateComponent();
        buffer.write(')');
      }
    } else if (node is DynamicSubComponent) {
      buffer
        ..write('$zapPrefix.DynamicComponent(')
        ..write(referenceExpression(node.expression))
        ..write(')');
    } else if (node is ReactiveIf) {
      buffer
        ..writeln('$zapPrefix.IfBlock((caseNum) {')
        ..writeln('switch (caseNum) {');

      for (var i = 0; i < node.whens.length; i++) {
        final component = node.whens[i].owningComponent!;

        buffer.writeln(
          'case $i: return ${_createSubFragment(component, 'this')};',
        );
      }

      final defaultCase = node.otherwise?.owningComponent;
      if (defaultCase != null) {
        buffer.writeln(
          'default: return ${_createSubFragment(defaultCase, 'this')};',
        );
      } else {
        buffer.writeln('default: return null;');
      }

      buffer.writeln('}})');
    } else if (node is ReactiveAsyncBlock) {
      final childComponent = node.fragment.owningComponent!;
      final name = node.fragment.resolvedScope
          .findForSubcomponent(SubcomponentVariableKind.asyncSnapshot)!
          .element
          .name;

      final create = _createSubFragment(childComponent, 'this');
      // If the component was optimized to a static html string, we don't have
      // to apply any updates.
      final update = _componentIsOptimizedAway(childComponent)
          ? '(_, __) {}'
          : '(fragment, snapshot) => '
                '(fragment as ${generator._nameForMisc(childComponent)})'
                '.$name = snapshot';

      final className = node.isStream ? 'StreamBlock' : 'FutureBlock';
      buffer.writeln('$zapPrefix.$className($create, $update)');
    } else if (node is ReactiveFor) {
      final subComponent = node.fragment.owningComponent!;

      final elementVariable = node.fragment.resolvedScope.findForSubcomponent(
        SubcomponentVariableKind.forBlockElement,
      )!;
      final indexVariable = node.fragment.resolvedScope.findForSubcomponent(
        SubcomponentVariableKind.forBlockIndex,
      );

      buffer.writeln('$zapPrefix.ForBlock(');

      // Write the function creating child nodes
      buffer.write('(element, index) => ');
      if (indexVariable != null) {
        buffer.write(_createSubFragment(subComponent, 'this, element, index'));
      } else {
        buffer.write(_createSubFragment(subComponent, 'this, element'));
      }

      // Write the function updating child nodes
      if (_componentIsOptimizedAway(subComponent)) {
        buffer.write(', (_, __, ___) {}');
      } else {
        final childClass = generator._nameForMisc(subComponent);

        buffer
          ..write(', (fragment, element, index) => ')
          ..write('(fragment as $childClass)')
          ..write('..${elementVariable.element.name} = element');

        if (indexVariable != null) {
          buffer.write('..${indexVariable.element.name} = index');
        }
      }

      buffer.write(')');
    } else if (node is MountSlot) {
      final createFallback = _createSubFragment(
        node.defaultContent.owningComponent!,
        componentThis,
      );

      final providedSlot = '$componentThis.${_slotVariable(node.slotName)}';
      final fallback = '() => $createFallback';

      buffer.write(
        '$zapPrefix.Slot($providedSlot ?? $fallback, $componentThis)',
      );
    } else {
      throw ArgumentError('Unknown node type: $node');
    }
  }

  void writePropertyAccessors() {
    final variablesThatNeedChanges = component.scope.declaredVariables.where((
      variable,
    ) {
      if (variable is DartCodeVariable) {
        return variable.isProperty;
      } else if (variable is SubcomponentVariable) {
        switch (variable.kind) {
          case SubcomponentVariableKind.asyncSnapshot:
          case SubcomponentVariableKind.forBlockElement:
          case SubcomponentVariableKind.forBlockIndex:
            return true;
        }
      } else {
        return false;
      }
    });

    for (final variable in variablesThatNeedChanges) {
      final element = variable.element;
      final type = dartTypeToString(variable.type);
      final name = generator._nameForVar(variable);

      // int get foo => $$_v0;
      buffer
        ..write(type)
        ..write(' get ')
        ..write(element.name)
        ..write(' => ')
        ..write(name)
        ..writeln(';');

      if (variable.isMutable) {
        // set foo (int value) {
        //   if (value != $$_v0) {
        //     $$_v0 = value;
        //     $invalidate(bitmask);
        //   }
        // }
        buffer
          ..writeln('set ${element.name} ($type value) {')
          ..writeln('  if (value != $name) {')
          ..writeln('    $name = value;');
        if (variable.needsUpdateTracking) {
          final update = _DartSourceRewriter(
            generator,
            component.scope,
            0,
            '',
            true,
            {},
          ).invalidateExpression(variable.updateBitmask.toString());
          buffer.writeln('    $update');
        }
        buffer
          ..writeln('  }')
          ..writeln('}');
      }
    }
  }

  void writeSetText(ReactiveText target) {
    buffer
      ..write(generator._nameForNode(target))
      ..write('.zapText = ');

    final expression = target.expression;
    buffer.write(referenceExpression(expression));

    if (target.needsToString) {
      // Call .toString() on the result
      buffer.write('.toString()');
    }
    buffer.writeln(';');
  }

  void writeDartWithPatchedReferences(
    AstNode dartCode, {
    bool patchSelf = true,
    Map<AstNode, WatchedExpression> watchedExpressions = const {},
  }) {
    buffer.write(
      _DartSourceRewriter.patchDartReferences(
        dartCode: dartCode,
        patchSelf: patchSelf,
        generator: generator,
        component: component,
        watchExpressions: watchedExpressions,
      ),
    );
  }
}

class _ComponentWriter extends _ComponentOrSubcomponentWriter {
  @override
  final Component component;
  final String name;

  _ComponentWriter(
    this.component,
    this.name,
    Generator generator,
    GenerationScope classScope,
  ) : super(generator, classScope);

  @override
  void write() {
    final prefix = generator.imports.zapImport;
    buffer.writeln('class $name extends $prefix.ZapComponent {');

    // Write variables:
    for (final variable
        in component.scope.declaredVariables.whereType<DartCodeVariable>()) {
      final name = generator._nameForVar(variable);
      // Variables need to be late because we only set them in the constructor's
      // body.
      buffer.write('late ');

      if (!variable.isMutable) buffer.write('final ');

      buffer
        ..write(dartTypeToString(variable.element.type))
        ..write(' ')
        ..write(name)
        ..write(';')
        ..writeln(' // ${variable.element.name}');
    }

    // Slots are also passed down as variables
    for (final slot in component.usedSlots) {
      final name = _slotVariable(slot);
      buffer.writeln('final $prefix.Fragment Function()? $name;');
    }

    // And DOM nodes
    writeCommonInstanceFields();

    writeConstructor();

    writeCreateMethod();
    writeRemoveMethod();
    writeUpdateMethod();
    writePropertyAccessors();

    // Write functions that were declared in the component
    for (final statement in component.instanceFunctions) {
      writeDartWithPatchedReferences(statement.functionDeclaration);
    }

    buffer.writeln('}');
  }

  void writeConstructor() {
    final zapPrefix = generator.imports.zapImport;

    buffer.write('$name(');
    final dartVariables = component.scope.declaredVariables
        .whereType<DartCodeVariable>();

    final properties = dartVariables.where((e) => e.isProperty);

    for (final variable in properties) {
      // Wrap properties in a ZapValue so that we can fallback to the default
      // value otherwise. We can't use optional parameters as the default
      // doesn't have to be a constant.
      // todo: Don't do that if the parameter is non-nullable
      final element = variable.element;
      final innerType = dartTypeToString(element.type);
      final type = '$zapPrefix.ZapValue<$innerType>?';
      buffer
        ..write(type)
        ..write(r' $')
        ..write(element.name)
        ..write(',');
    }

    // Also write slots
    for (final slot in component.usedSlots) {
      buffer.write('this.${_slotVariable(slot)},');
    }

    buffer.writeln(') {');

    for (final initializer in component.componentInitializers) {
      if (initializer is InitializeStatement) {
        final initializedVariable = initializer.initializedVariable;
        final statement = initializer.dartStatement;

        // Rewrite variable declarations to instead initialize the field on
        // the component instance.
        if (statement is VariableDeclarationStatement &&
            initializedVariable != null) {
          final field = generator._nameForVar(initializedVariable);
          final knownInitializer = initializedVariable.initializer;

          if (knownInitializer != null) {
            final name = referenceExpression(knownInitializer);

            buffer.write('$field = $name;');
          } else if (generator.component.typeSystem.isNullable(
            initializedVariable.type,
          )) {
            // If this were a regular variable, it would have been initialized
            // to null at the declaration. So, let's set the field to null to
            // mirror that.
            buffer.writeln('$field = null;');
          }
        } else {
          // Not a zap variable, just write the original statement
          writeDartWithPatchedReferences(initializer.dartStatement);
        }
      } else if (initializer is InitialSideEffect) {
        // Just call the method implementing the side-effect
        final function = generator._nameForMisc(initializer.effect);
        buffer.writeln('$function();');
      } else if (initializer is InitializeProperty) {
        // We have the property as $property, wrapped in a nullable
        // ZapValue.
        // So write `<type> variable = $variable != null ? $variable.value : <d>`
        final variable = initializer.variable;
        final element = variable.element;

        buffer
          ..write(generator._nameForVar(variable))
          ..write(r' = $')
          ..write(element.name)
          ..write(' != null ? ')
          ..write(r'$')
          ..write(element.name)
          ..write('.value : (');

        final declaration = variable.declaration;
        final defaultExpr = declaration is VariableDeclaration
            ? declaration.initializer
            : null;
        final isNullable = generator.component.typeSystem.isNullable(
          variable.type,
        );

        if (defaultExpr != null) {
          writeDartWithPatchedReferences(defaultExpr);
        } else if (isNullable) {
          buffer.write('null');
        } else {
          // No initializer and no value set -> error
          final argumentError = prefixIdentifier('ArgumentError');
          buffer.write(
            'throw $argumentError(${dartStringLiteral('Parameter ${element.name} is required!')})',
          );
        }

        buffer.write(');');
      }
    }

    buffer.write('}');
  }
}

class _SubComponentWriter extends _ComponentOrSubcomponentWriter {
  @override
  final ResolvedSubComponent component;

  _SubComponentWriter(
    this.component,
    Generator generator,
    GenerationScope classScope,
  ) : super(generator, classScope);

  @override
  void write() {
    final zapPrefix = generator.imports.zapImport;

    final name = generator._nameForMisc(component);
    buffer.writeln('class $name extends $zapPrefix.Fragment {');

    final parent = component.parent!;
    final parentType = parent is Component
        ? generator.component.componentName
        : generator._nameForMisc(parent);

    final needsInitialization = <String>[];

    // Inside subfragments, variables are instiated by the parent component
    // before calling create()
    for (final variable
        in component.scope.declaredVariables.cast<SubcomponentVariable>()) {
      final type = dartTypeToString(variable.type);
      final name = generator._nameForVar(variable);

      switch (variable.kind) {
        case SubcomponentVariableKind.asyncSnapshot:
          buffer.writeln(
            '$type $name = const $zapPrefix.ZapSnapshot.unresolved(); // ${variable.element.name}',
          );
          break;
        case SubcomponentVariableKind.forBlockElement:
        case SubcomponentVariableKind.forBlockIndex:
          needsInitialization.add(name);
          buffer.writeln('$type $name; // ${variable.element.name}');
          break;
      }
    }

    final initializers = [
      _parentField,
    ].followedBy(needsInitialization).map((e) => 'this.$e').join(',');

    buffer
      ..writeln('final $parentType $_parentField;')
      ..writeln('$name($initializers);');

    writeCommonInstanceFields();
    writeCreateMethod();
    writeUpdateMethod();
    writeRemoveMethod();
    writePropertyAccessors();

    buffer.writeln('}');
  }
}

/// A writer for Dart types that automatically adds the right imports for all
/// types.
class _DartTypeWriter extends UnifyingTypeVisitor<void> {
  final Generator generator;
  final StringBuffer buffer;

  _DartTypeWriter(this.generator, this.buffer);

  void _writeSuffix(NullabilitySuffix suffix) {
    switch (suffix) {
      case NullabilitySuffix.question:
        return buffer.write('?');
      case NullabilitySuffix.star:
        return buffer.write('*');
      case NullabilitySuffix.none:
        return;
    }
  }

  void _writeElement(Element element, String name) {
    final library = element.library;
    if (library != null && library != generator.component.resolvedTmpLibrary) {
      final import = generator.imports.importForLibrary(library);
      buffer.write('$import.');
    }

    buffer.write(name);
  }

  @override
  void visitDartType(DartType type) {
    // Unhandled type
  }

  @override
  void visitDynamicType(DynamicType type) {
    buffer.write('dynamic');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitFunctionType(FunctionType type) {
    type.returnType.accept(this);

    buffer.write(' Function');
    final formals = type.typeFormals;
    if (formals.isNotEmpty) {
      buffer.write('<');
      var i = 0;
      for (final arg in formals) {
        if (i != 0) {
          buffer.write(', ');
        }

        buffer.write(arg.name);
        final bound = arg.bound;
        if (bound != null) {
          buffer.write(' extends ');
          bound.accept(this);
        }
        i++;
      }
      buffer.write('>');
    }

    // Write parameters
    buffer.write('(');
    var i = 0;

    String? activeOptionalBlock;

    for (final parameter in type.parameters) {
      if (parameter.isNamed) {
        if (activeOptionalBlock == null) {
          buffer.write('{');
          i = 0; // Don't put a comma before the first named parameter
          activeOptionalBlock = '}';
        }
      } else if (parameter.isOptionalPositional) {
        if (activeOptionalBlock == null) {
          buffer.write('[');
          i = 0; // Don't put a comma before the first optional parameter
          activeOptionalBlock = ']';
        }
      }

      if (i != 0) {
        buffer.write(', ');
      }

      parameter.type.accept(this);
      if (parameter.isNamed) {
        buffer.write(' ${parameter.name}');
      }
      i++;
    }

    if (activeOptionalBlock != null) {
      buffer.write(activeOptionalBlock);
    }

    buffer.write(')');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitInterfaceType(InterfaceType type) {
    final alias = type.alias;
    if (alias != null) {
      _writeElement(alias.element, alias.element.name);
    } else {
      _writeElement(type.element, type.element.name);
    }

    if (type.typeArguments.isNotEmpty) {
      buffer.write('<');
      var i = 0;
      for (final arg in type.typeArguments) {
        if (i != 0) {
          buffer.write(', ');
        }

        arg.accept(this);
        i++;
      }
      buffer.write('>');
    }

    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitInvalidType(InvalidType type) {
    buffer.write('dynamic');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitNeverType(NeverType type) {
    buffer.write('Never');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitRecordType(RecordType type) {
    buffer.write('(');
    var first = true;

    for (final field in type.positionalFields) {
      if (!first) {
        buffer.write(', ');
      }
      first = false;

      field.type.accept(this);
    }

    if (type.namedFields.isNotEmpty) {
      buffer.write('{');
      first = true;
      for (final field in type.namedFields) {
        if (!first) {
          buffer.write(', ');
        }
        first = false;

        field.type.accept(this);
        buffer
          ..write(' ')
          ..write(field.name);
      }
      buffer.write('}');
    }

    buffer.write(')');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitTypeParameterType(TypeParameterType type) {
    buffer.write(type.element.name);
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitVoidType(VoidType type) {
    buffer.write('void');
    _writeSuffix(type.nullabilitySuffix);
  }
}

class _DartSourceRewriter extends GeneralizingAstVisitor<void> {
  final Generator generator;
  final ZapVariableScope? scope;
  final ZapVariableScope rootScope;
  final Map<AstNode, WatchedExpression> watchExpressions;

  final bool patchSelf;

  final int startOffsetInDart;
  int skew = 0;
  String content;

  _DartSourceRewriter(
    this.generator,
    this.scope,
    this.startOffsetInDart,
    this.content,
    this.patchSelf,
    this.watchExpressions,
  ) : rootScope = generator.component.component.scope;

  static String patchDartReferences({
    required AstNode dartCode,
    required Generator generator,
    bool patchSelf = true,
    ComponentOrSubcomponent? component,
    Map<AstNode, WatchedExpression> watchExpressions = const {},
  }) {
    final originalCode = generator.prepareResult.temporaryDartFile.contents
        .substring(dartCode.offset, dartCode.offset + dartCode.length);
    final rewriter = _DartSourceRewriter(
      generator,
      component?.scope,
      dartCode.offset,
      originalCode,
      patchSelf,
      watchExpressions,
    );
    dartCode.accept(rewriter);
    return rewriter.content;
  }

  /// Replaces the range from [start] with length [originalLength] in the
  /// [content] string.
  ///
  /// The [skew] value is set accordingly so that [start] can refer to the
  /// original offset before making any changes. This only works when
  /// [_replaceRange] is called with increasing, non-overlapping offsets.
  void _replaceRange(int start, int originalLength, String newContent) {
    var actualStart = skew + start - startOffsetInDart;

    content = content.replaceRange(
      actualStart,
      actualStart + originalLength,
      newContent,
    );
    skew += newContent.length - originalLength;
  }

  void _replaceNode(SyntacticEntity node, String newContent) {
    _replaceRange(node.offset, node.length, newContent);
  }

  BaseZapVariable? _variableFor(Element? element) {
    ZapVariableScope? scope = this.scope;

    while (scope != null) {
      final variable = scope.declaredVariables.firstWhereOrNull(
        (v) => v.element == element,
      );
      if (variable != null) {
        return variable;
      }

      scope = scope.parent;
    }

    return null;
  }

  /// Writes Dart code necessary to access variables defined in the
  /// [targetScope].
  ///
  /// When the [targetScope] is the current [scope], the result will be empty.
  /// When its a parent of the current scope, the result would be `parent.`.
  /// For scopes further up, `parent.` would be repeated.
  String _prefixFor(ZapVariableScope targetScope, {bool trailingDot = true}) {
    var current = scope;
    if (current == null) {
      return trailingDot ? 'this.' : '';
    }

    final result = StringBuffer();

    while (current != targetScope) {
      if (result.isNotEmpty) {
        result.write('.');
      }

      result.write(_parentField);
      current = current!.parent!;
    }

    if (trailingDot && result.isNotEmpty) {
      result.write('.');
    }

    return result.toString();
  }

  String invalidateExpression(String bitmaskCode) {
    if (scope == rootScope) {
      return '\$invalidate($bitmaskCode);';
    } else {
      final prefix = _prefixFor(rootScope);
      return '$prefix\$invalidateSubcomponent(this, $bitmaskCode);';
    }
  }

  void _visitCompoundAssignmentExpression(CompoundAssignmentExpression node) {
    final target = node.writeElement;
    final variable = _variableFor(target);
    final notifyUpdate = variable != null && variable.needsUpdateTracking;

    // Wrap the assignment in an $invalidateAssign block so that it can still
    // be used as an expression while also scheduling a node update!
    if (notifyUpdate) {
      final updateCode = variable.updateBitmask;

      if (scope == rootScope) {
        _replaceRange(node.offset, 0, '\$invalidateAssign($updateCode, ');
      } else {
        final prefix = _prefixFor(rootScope);
        _replaceRange(
          node.offset,
          0,
          '$prefix.\$invalidateAssignSubcomponent(this, $updateCode, ',
        );
      }
    }

    node.visitChildren(this);

    if (notifyUpdate) {
      _replaceRange(node.offset + node.length, 0, ')');
    }
  }

  /// For syntactic constructions of the form `x.y`, where `x` is an import
  /// prefix identifier, rewrites the construction to just `y`. Visiting the
  /// simple identifier will add the necessary prefix.
  void _handleTarget(Expression? left, Token? operator) {
    if (left is SimpleIdentifier) {
      final target = left.staticElement;
      if (target is PrefixElement && operator != null) {
        _replaceNode(left, '');
        _replaceNode(operator, '');
      }
    }
  }

  void _patchIdentifier(SyntacticEntity entity, Element? target) {
    final targetLibrary = target?.library;

    if (targetLibrary != generator.component.resolvedTmpLibrary) {
      // Referencing an element from an import, add necessary import prefix.
      final isTopLevel =
          targetLibrary != null &&
          targetLibrary.topLevelElements.contains(target);

      if (isTopLevel) {
        final importPrefix = generator.imports.importForLibrary(targetLibrary);
        _replaceRange(entity.offset, 0, '$importPrefix.');
      } else if (target is ExecutableElement &&
          !target.isStatic &&
          target.enclosingElement3 is ExtensionElement) {
        final extension = target.enclosingElement3 as ExtensionElement;
        final name = extension.name;

        // Target is from an extension, import that extension without an alias
        // so that the extension invocation continues to work.
        if (name != null) {
          generator.imports.importWithoutAlias(extension.library, name);
        }
      }
      return;
    }

    final variable = _variableFor(target);

    if (variable is SelfReference) {
      // Inside the main component, we can replace `self` with `this`. In
      // inner components, we have to walk the parent.

      if (patchSelf) {
        if (rootScope == scope) {
          _replaceNode(entity, 'this');
        } else {
          final prefix = _prefixFor(rootScope, trailingDot: false);
          _replaceNode(entity, prefix);
        }
      }
    } else if (target is FunctionElement &&
        generator.component.userDefinedFunctions.contains(target)) {
      final newName = generator._nameForFunction(target);
      final prefix = _prefixFor(rootScope);

      _replaceNode(entity, '$prefix$newName');
    } else if (variable != null) {
      final prefix = _prefixFor(variable.scope);
      final name = generator._nameForVar(variable);

      final replacement = '$prefix$name /* ${target?.name} */';
      _replaceNode(entity, replacement);
    }
  }

  @override
  void visitFunctionDeclaration(FunctionDeclaration node) {
    node.returnType?.accept(this);
    _patchIdentifier(node.name, node.declaredElement);
    node.functionExpression.accept(this);
  }

  @override
  void visitMethodInvocation(MethodInvocation node) {
    if (isWatchFunctionFromDslLibrary(node.methodName)) {
      // Replace `watch(foo) with `$watchImpl(foo, updateFlag: 123)`
      final prefix = _prefixFor(rootScope);
      final resolvedWatch =
          watchExpressions[node.argumentList.arguments.single];

      if (resolvedWatch != null) {
        _replaceNode(node.methodName, '$prefix\$watchImpl');

        visitNode(node.argumentList.arguments.single);

        final updateFlag = resolvedWatch.updateSlot!;
        _replaceNode(node.argumentList.rightParenthesis, ', $updateFlag)');

        return;
      }
    }

    _handleTarget(node.target, node.operator);
    super.visitMethodInvocation(node);
  }

  @override
  void visitNode(AstNode node) {
    if (watchExpressions.containsKey(node)) {
      final target = watchExpressions[node]!.expression;
      final getterName = generator._nameForMisc(target);

      _replaceNode(node, '${_prefixFor(target.scope)}$getterName');
    } else {
      super.visitNode(node);
    }
  }

  @override
  void visitInterpolationExpression(InterpolationExpression node) {
    if (node.expression case final SimpleIdentifier expression) {
      // Interpolated variables must be wrapped in braces since the
      // replacement identifier will have `$` in the name.
      //
      // For example, '$localVariable' becomes '${_$v1 /* localVariable */}'.
      final missingBraces = node.rightBracket == null;
      if (missingBraces) {
        _replaceRange(node.leftBracket.end, 0, '{');
      }
      _patchIdentifier(expression, expression.staticElement);
      if (missingBraces) {
        _replaceRange(expression.end, 0, '}');
      }
    } else {
      super.visitInterpolationExpression(node);
    }
  }

  @override
  void visitAssignmentExpression(AssignmentExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitPrefixExpression(PrefixExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitPrefixedIdentifier(PrefixedIdentifier node) {
    final targetOfPrefix = node.prefix.staticElement;
    if (targetOfPrefix is PrefixElement) {
      _handleTarget(node.prefix, node.period);
      visitSimpleIdentifier(node.identifier);
    } else {
      super.visitPrefixedIdentifier(node);
    }
  }

  @override
  void visitPostfixExpression(PostfixExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitNamedType(NamedType node) {
    final prefix = node.importPrefix;
    if (prefix != null) {
      // patchIdentifier will add the right identifier if needed.
      _replaceNode(prefix, '');
    }
    _patchIdentifier(node.name2, node.element);

    node.typeArguments?.accept(this);
  }

  @override
  void visitSimpleIdentifier(SimpleIdentifier node) {
    _patchIdentifier(node, node.staticElement);
  }
}
