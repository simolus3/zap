import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/syntactic_entity.dart';
import 'package:analyzer/dart/ast/token.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/type_visitor.dart';
import 'package:build/build.dart';
import 'package:collection/collection.dart';

import '../resolver/component.dart';
import '../resolver/dart.dart';
import '../resolver/flow.dart';
import '../resolver/preparation.dart';
import '../resolver/reactive_dom.dart';
import '../resolver/resolver.dart';
import '../utils/dart.dart';
import 'imports.dart';
import 'options.dart';
import 'ssr/node_to_text.dart';
import 'tree.dart';

const _prefix = r'_$';
const _parentField = '${_prefix}parent';

class Generator {
  final GenerationScope libraryScope = GenerationScope();
  late final ImportsTracker imports;

  final GenerationOptions options;

  final PrepareResult prepareResult;
  final ResolvedComponent component;

  final Map<BaseZapVariable, String> _varNames = {};
  final Map<ReactiveNode, String> _nodeNames = {};
  final Map<FunctionElement, String> _functionNames = {};
  final Map<Object, String> _miscNames = {};

  String get zapPrefix => imports.zapImport;

  Generator(this.component, this.prepareResult, this.options, AssetId output) {
    imports = ImportsTracker(libraryScope.inner(), output);
  }

  String _nameForVar(BaseZapVariable variable) {
    return _varNames.putIfAbsent(variable, () {
      return '${_prefix}v${_varNames.length}';
    });
  }

  String _nameForNode(ReactiveNode node) {
    return _nodeNames.putIfAbsent(node, () {
      return '${_prefix}n${_nodeNames.length}';
    });
  }

  String _nameForFunction(FunctionElement fun) {
    return _functionNames.putIfAbsent(fun, () => '${_prefix}fun_${fun.name}');
  }

  String _nameForMisc(Object key) {
    return _miscNames.putIfAbsent(
        key, () => '_${_prefix}t${_miscNames.length}');
  }

  void write() {
    imports.imports.writeln('// Generated by zap_dev, do not edit!');
    _writeComponent(component.component);

    // Write top-level members declared outside of the component (in a
    // `<script context="module">` scope).
    for (final declaration in component.declarationsFromModuleScope) {
      libraryScope.leaf().write(_DartSourceRewriter.patchDartReferences(
            dartCode: declaration,
            generator: this,
            patchSelf: false, // Not in a component, can't use `self`.
          ));
    }

    imports.ensureImportsAreWritten();
  }

  void _writeComponent(ComponentOrSubcomponent component) {
    _ComponentOrSubcomponentWriter writer;
    final scope = libraryScope.inner(ScopeLevel.$class);
    final opt = this.component.optimization.forComponent(component);

    if (component is Component) {
      writer = _ComponentWriter(
          component, this.component.componentName, this, scope);
    } else {
      // Instead of writing a full class, we can write this fragment as a static
      // node.
      if (opt.isCompileTimeConstant) {
        _writeConstantComponent(component as ResolvedSubComponent);
        return;
      }

      writer =
          _SubComponentWriter(component as ResolvedSubComponent, this, scope);
    }

    writer.write();

    component.children.forEach(_writeComponent);
  }

  void _writeConstantComponent(ResolvedSubComponent component) {
    final name = _nameForMisc(component);
    final writer = NodeWriter();
    component.fragment.rootNodes.forEach(writer.writeNode);

    libraryScope.leaf().write('final $name = $zapPrefix.RawHtml'
        '(${dartStringLiteral(writer.buffer.toString())});');
  }
}

abstract class _ComponentOrSubcomponentWriter {
  final Generator generator;
  final GenerationScope classScope;
  final StringBuffer buffer;

  ComponentOrSubcomponent get component;

  _ComponentOrSubcomponentWriter(this.generator, this.classScope)
      : buffer = classScope.leaf();

  void write();

  String get componentThis {
    if (component is Component) {
      // Root component
      return 'this';
    } else {
      return _DartSourceRewriter(
              generator, component.scope, 0, '', true, const {})
          ._prefixFor(generator.component.component.scope, trailingDot: false);
    }
  }

  String get atOverride => '@${prefixIdentifier('override')}';

  String prefixIdentifier(String identifier, [String from = 'dart:core']) {
    final uri = Uri.parse(from);
    return '${generator.imports.importForUri(uri)}.$identifier';
  }

  String jaspr(String identifier) =>
      prefixIdentifier(identifier, 'package:jaspr/ui.dart');

  String dartTypeToString(DartType type) {
    final buffer = StringBuffer();

    type.accept(_DartTypeWriter(generator, buffer));
    return buffer.toString();
  }

  String _slotVariable(String? slot) {
    return '\$slot_${slot ?? ''}';
  }

  bool _componentIsOptimizedAway(ComponentOrSubcomponent component) {
    final opt = generator.component.optimization.forComponent(component);
    return opt.isCompileTimeConstant;
  }

  String _createSubFragment(
      ComponentOrSubcomponent subComponent, String constructorArguments) {
    final name = generator._nameForMisc(subComponent);

    if (_componentIsOptimizedAway(subComponent)) {
      // We'll write a top-level field for this constant fragment.
      return name;
    } else {
      final createFragment = '$name($constructorArguments)';
      return '${generator.imports.zapImport}.FragmentComponent(() => $createFragment)';
    }
  }

  String referenceExpression(ResolvedDartExpression expression) {
    final ownScope = component.scope;
    final expressionScope = expression.scope;

    final prefix =
        _DartSourceRewriter(generator, ownScope, 0, '', true, const {})
            ._prefixFor(expressionScope);

    return '$prefix${generator._nameForMisc(expression)}';
  }

  /// Writes getters to evaluate expressions used in the component.
  void writeCommonInstanceFields() {
    // Create getters for expressions, avoiding duplicate code when an
    // expression is used more than once.
    for (final usedExpression in component.scope.usedDartExpressions) {
      final name = generator._nameForMisc(usedExpression);

      buffer
        ..write(dartTypeToString(usedExpression.staticType))
        ..write(' get $name => ');
      writeDartWithPatchedReferences(
        usedExpression.expression,
        // When this expression uses `watch(<x>)`, refer to the getter we'll
        // generate for `<x>` instead of duplicating the source code.
        watchedExpressions: {
          for (final expr in usedExpression.watched)
            expr.expression.expression: expr
        },
      );
      buffer.writeln(';');
    }

    // Similarly, create methods for side-effect actions to avoid emitting the
    // same code in the constructor and in `update()`.
    for (final flow in component.flows) {
      final action = flow.action;
      if (action is SideEffect) {
        final name = generator._nameForMisc(action);

        buffer.write('void $name() {');
        writeDartWithPatchedReferences(action.statement);
        buffer.write(';}');
      }

      // Mutable stream subscriptions are stored as instance variables too
      if (!flow.isOneOffAction && action is RegisterEventHandler) {
        final dartAsync =
            generator.imports.importForUri(Uri.parse('dart:async'));
        final type = dartTypeToString(action.handler.dartEventType);

        buffer
          ..write('late ')
          ..write('$dartAsync.StreamSubscription<$type> ')
          ..write(generator._nameForMisc(action.handler))
          ..writeln(';');
      }
    }
  }

  void generateEventCallback(EventHandler handler) {
    if (handler.isForwarding) {
      buffer.write('$componentThis.forwardEvents()');
    } else {
      callbackForEventHandler(handler);
    }
  }

  void registerEventHandler(EventHandler handler) {
    final knownEvent = handler.knownType;
    final parent = handler.parent;
    final node = generator._nameForNode(parent);

    void writeStreamToListenTo() {
      // Write the `Stream` expression for this event handler.
      if (parent is SubComponent) {
        final type = dartTypeToString(handler.dartEventType);
        buffer.write('$node.componentEvents<$type>'
            '(${dartStringLiteral(handler.event)})');
      } else {
        buffer.write('${generator.imports.webImport}.');

        if (knownEvent != null) {
          buffer.write(knownEvent.providerExpression);
        } else {
          buffer.write("const EventStreamProvider('${handler.event}')");
        }

        buffer.write('.forElement($node');
        if (handler.isCapturing) {
          buffer.write(', useCapture = true');
        }
        buffer.write(')');
      }

      if (handler.modifier.isNotEmpty) {
        // Transform the event stream to account for the modifiers.
        buffer.write('.withModifiers(');

        for (final modifier in handler.modifier) {
          switch (modifier) {
            case EventModifier.preventDefault:
              buffer.write('preventDefault: true,');
              break;
            case EventModifier.stopPropagation:
              buffer.write('stopPropagation: true,');
              break;
            case EventModifier.passive:
              buffer.write('passive: true,');
              break;
            case EventModifier.nonpassive:
              buffer.write('passive: false,');
              break;
            case EventModifier.once:
              buffer.write('once: true,');
              break;
            case EventModifier.self:
              buffer.write('onlySelf: true,');
              break;
            case EventModifier.trusted:
              buffer.write('onlyTrusted: true,');
              break;
            case EventModifier.capture:
            // Handled by useCapture: true above
          }
        }

        buffer.write(')');
      }
    }

    if (handler.isForwarding) {
      buffer.write('$componentThis.forwardEvents(');
      writeStreamToListenTo();
      buffer.write(');');
    } else {
      writeStreamToListenTo();
      buffer.write('.listen(');
      callbackForEventHandler(handler);
      buffer.write(');');
    }
  }

  void callbackForEventHandler(EventHandler handler) {
    final listener = handler.listener!;

    if (handler.isNoArgsListener) {
      // The handler does not take any arguments, so we have to wrap it in a
      // function that does.
      buffer
        ..write('(_) {(')
        ..write(referenceExpression(listener))
        ..write(')();}');
    } else {
      // A tear-off will do
      buffer.write(referenceExpression(listener));
    }
  }

  void writeDartWithPatchedReferences(
    AstNode dartCode, {
    bool patchSelf = true,
    Map<AstNode, WatchedExpression> watchedExpressions = const {},
  }) {
    buffer.write(
      _DartSourceRewriter.patchDartReferences(
        dartCode: dartCode,
        patchSelf: patchSelf,
        generator: generator,
        component: component,
        watchExpressions: watchedExpressions,
      ),
    );
  }

  String createKey(ReactiveNode node) {
    final name = generator._nameForNode(node);
    return 'const ${jaspr('Key')}(${dartStringLiteral(name)})';
  }

  void writeNodeAsComponentExpression(ReactiveNode node) {
    final key = createKey(node);

    switch (node) {
      case ConstantText(:final text):
        buffer
          ..write('const ')
          ..write(jaspr('Text'))
          ..write('(')
          ..write(dartStringLiteral(text))
          ..write(', key: $key')
          ..write(')');
      case ReactiveText(:final expression):
        buffer
          ..write(jaspr('Text'))
          ..write('(')
          ..write(referenceExpression(expression));
        if (node.needsToString) {
          buffer.write('.toString()');
        }
        buffer
          ..write(', key: $key')
          ..write(')');
      case ReactiveElement():
        // TODO: Binders / global key?

        buffer
          ..write(jaspr('DomComponent'))
          ..write('(')
          ..write('tag: ${dartStringLiteral(node.tagName)},')
          ..write('key: $key,');

        if (node.children.isNotEmpty) {
          buffer.writeln('children: [');
          for (final child in node.children) {
            writeNodeAsComponentExpression(child);
            buffer.writeln(',');
          }
          buffer.write('],');
        }

        if (node.attributes.isNotEmpty) {
          buffer.writeln('attributes: {');
          node.attributes.forEach((name, value) {
            void writeKey() {
              buffer
                ..write(dartStringLiteral(name))
                ..write(': ');
            }

            switch (value.mode) {
              case AttributeMode.setValue:
                writeKey();

                if (name == 'class' &&
                    generator.component.cssClassName != null) {
                  // Make sure the scoped css class is still included when setting the
                  // class attribute
                  buffer
                    ..write('$zapPrefix.ZapGeneratedState.classAttribute(')
                    ..write(
                        dartStringLiteral(generator.component.cssClassName!))
                    ..write(', ')
                    ..write(referenceExpression(value.backingExpression))
                    ..write('.toString())');
                } else {
                  // Just emit attributes[key] = value.toString()
                  buffer
                    ..write(referenceExpression(value.backingExpression))
                    ..write('.toString()');
                }
              case AttributeMode.addIfTrue:
                buffer.write(
                    'if (${referenceExpression(value.backingExpression)})');
                writeKey();
                buffer.write("'true'");
              case AttributeMode.setIfNotNullClearOtherwise:
                buffer.write(
                    'if (${referenceExpression(value.backingExpression)} != null)');
                writeKey();
                buffer.write("'true'");
            }

            buffer.writeln(',');
          });
          buffer.write('},');
        }

        if (node.binders.isNotEmpty) {
          throw 'todo binders';
        }

        if (node.eventHandlers.isNotEmpty) {
          buffer.writeln('events: {');
          for (final handler in node.eventHandlers) {
            buffer.write('${dartStringLiteral(handler.event)}:');
            generateEventCallback(handler);
            buffer.writeln(',');
          }
          buffer.write('}');
        }

        buffer.write(')');
      case MountSlot():
        final name = _slotVariable(node.slotName);
        buffer
          ..write(componentThis)
          ..write('.component.')
          ..write(name)
          ..write(' ?? ')
          ..write(_createSubFragment(
              node.defaultContent.owningComponent!, componentThis));
      case SubComponent():
        final prefix = generator.imports
            .importForLibrary(node.component.temporaryApiClass.library);
        final typeName = '$prefix.${node.component.temporaryApiClass.name}';

        buffer.write('$typeName(');

        // Write properties passed down to the component.
        for (final property in node.component.parameters) {
          final name = property.key;
          final actualValue = node.expressions[name];

          if (actualValue == null) {
            buffer.write('null');
          } else {
            // Wrap values in a ZapValue to distinguish between set and absent
            // parameters.
            buffer
              ..write('$zapPrefix.ZapValue(')
              ..write(referenceExpression(actualValue))
              ..write(')');
          }

          buffer.write(',');
        }

        // Also write slots passed down.
        for (final slot in node.component.slotNames) {
          final child = slot == null ? node.defaultSlot : node.slots[slot];

          buffer
            ..write(_slotVariable(slot))
            ..write(': ');

          if (child == null) {
            buffer.write('null');
          } else {
            buffer.write(_createSubFragment(child.owningComponent!, 'this'));
          }

          buffer.write(',');
        }

        buffer.write('key: $key,');
        buffer.writeln(')');
      case ReactiveAsyncBlock():
        final isStream = node.isStream;
        buffer
          ..write(generator.imports.jasprImport)
          ..write(isStream ? '.StreamBuilder' : '.FutureBuilder')
          ..write('<');
        node.type.accept(_DartTypeWriter(generator, buffer));
        buffer.write('>(');

        buffer
          ..write(isStream ? 'stream: ' : 'future: ')
          ..write(referenceExpression(node.expression))
          ..writeln(',')
          ..write('builder: (_, snapshot) => ')
          ..write(_createSubFragment(
              node.fragment.owningComponent!, 'this, snapshot'))
          ..write(',');

        buffer.writeln('key: $key,');
        buffer.write(')');
      case DynamicSubComponent():
        buffer.write(referenceExpression(node.expression));
      case ReactiveIf():
      case ReactiveFor():
        // These two are hard to generate as an expression, so wrap in builder
        buffer.writeln('${jaspr('Builder')}(key: $key, builder: (_) sync* {');
        yieldNode(node);
        buffer.writeln('})');
      case ReactiveRawHtml():
        final prefix = generator.imports.zapImport;
        buffer
            .write('$prefix.RawHtml(${referenceExpression(node.expression)})');
      case ReactiveKeyBlock():
        throw UnimplementedError('Unknown: $node');
    }
  }

  void yieldNode(ReactiveNode node) {
    switch (node) {
      case ReactiveIf():
        for (final (i, condition) in node.conditions.indexed) {
          if (i != 0) {
            buffer.write('else ');
          }
          final then = node.whens[i];

          buffer.writeln('if (${referenceExpression(condition)}) {');
          buffer.writeln(
              'yield ${_createSubFragment(then.owningComponent!, componentThis)};');
          buffer.writeln('}');
        }

        if (node.otherwise case final otherwise?) {
          buffer.writeln('else {');
          buffer.writeln(
              'yield ${_createSubFragment(otherwise.owningComponent!, componentThis)};');
          buffer.writeln('}');
        }
      case ReactiveFor():
        final subComponent = node.fragment.owningComponent!;

        final iterable = node.expression;
        final indexVariable = node.fragment.resolvedScope
            .findForSubcomponent(SubcomponentVariableKind.forBlockIndex);

        // Write the function creating child nodes
        if (indexVariable != null) {
          buffer
            ..writeln(
                'for (final (i, element) in ${referenceExpression(iterable)}.indexed) {')
            ..writeln(
                'yield ${_createSubFragment(subComponent, 'this, element, i')};')
            ..writeln('}');
        } else {
          buffer
            ..writeln(
                'for (final element in ${referenceExpression(iterable)}) {')
            ..writeln(
                'yield ${_createSubFragment(subComponent, 'this, element')};')
            ..writeln('}');
        }
      default:
        buffer.write('yield ');
        writeNodeAsComponentExpression(node);
        buffer.writeln(';');
    }
  }

  void writeBuildMethod() {
    final jaspr = generator.imports.jasprImport;

    buffer
      ..writeln(atOverride)
      ..write(prefixIdentifier('Iterable'))
      ..writeln(
          '<$jaspr.Component> build($jaspr.BuildContext context) sync* {');

    for (final node in component.fragment.rootNodes) {
      yieldNode(node);
    }

    buffer.writeln('}');
  }
}

class _ComponentWriter extends _ComponentOrSubcomponentWriter {
  @override
  final Component component;
  final String name;

  _ComponentWriter(this.component, this.name, Generator generator,
      GenerationScope classScope)
      : super(generator, classScope);

  @override
  void write() {
    final jaspr = generator.imports.jasprImport;
    final prefix = generator.imports.zapImport;
    final stateName = generator.component.componentStateName;

    // Write a Jaspr component class first:
    buffer.writeln('final class $name extends $jaspr.StatefulComponent {');
    buffer.write('const $name({super.key,');

    final componentFields = StringBuffer();

    for (final property in component.scope.declaredVariables
        .whereType<DartCodeVariable>()
        .where((e) => e.isProperty)) {
      // Wrap properties in a ZapValue so that we can fallback to the default
      // value otherwise. We can't use optional parameters as the default
      // doesn't have to be a constant.
      // todo: Don't do that if the parameter is non-nullable
      final element = property.element;
      final innerType = dartTypeToString(element.type);
      final type = '$prefix.ZapValue<$innerType>?';
      buffer
        ..write(type)
        ..write(' this.')
        ..write(element.name)
        ..write(',');

      componentFields.writeln('final $type ${property.element.name};');
    }

    // Slots are also passed down as variables
    for (final slot in component.usedSlots) {
      final name = _slotVariable(slot);
      componentFields.writeln('final $jaspr.Component? $name;');
      buffer.writeln('$jaspr.Component? this.$name,');
    }

    buffer.writeln('});');

    buffer
      ..writeln(componentFields)
      ..writeln(atOverride)
      ..write('$stateName createState() => $stateName();')
      ..writeln('}');

    // All component logic is implemented as a jaspr State implementation.
    buffer.writeln(
        'final class $stateName extends $prefix.ZapGeneratedState<$name> {');

    // Write variables:
    for (final variable
        in component.scope.declaredVariables.whereType<DartCodeVariable>()) {
      final name = generator._nameForVar(variable);
      // Variables need to be late because we only set them when the state is
      // initialized.
      buffer.write('late ');

      if (!variable.isMutable) buffer.write('final ');

      buffer
        ..write(dartTypeToString(variable.element.type))
        ..write(' ')
        ..write(name)
        ..write(';')
        ..writeln(' // ${variable.element.name}');
    }

    writeCommonInstanceFields();
    writeInitState();
    writeBuildMethod();

    // Write functions that were declared in the component
    for (final statement in component.instanceFunctions) {
      writeDartWithPatchedReferences(statement.functionDeclaration);
    }

    buffer.writeln('}');
  }

  void writeInitState() {
    buffer
      ..writeln(atOverride)
      ..writeln('void initState() {')
      ..writeln('super.initState();');

    for (final initializer in component.componentInitializers) {
      if (initializer is InitializeStatement) {
        final initializedVariable = initializer.initializedVariable;
        final statement = initializer.dartStatement;

        // Rewrite variable declarations to instead initialize the field on
        // the component instance.
        if (statement is VariableDeclarationStatement &&
            initializedVariable != null) {
          final field = generator._nameForVar(initializedVariable);
          final knownInitializer = initializedVariable.initializer;

          if (knownInitializer != null) {
            final name = referenceExpression(knownInitializer);

            buffer.write('$field = $name;');
          } else if (generator.component.typeSystem
              .isNullable(initializedVariable.type)) {
            // If this were a regular variable, it would have been initialized
            // to null at the declaration. So, let's set the field to null to
            // mirror that.
            buffer.writeln('$field = null;');
          }
        } else {
          // Not a zap variable, just write the original statement
          writeDartWithPatchedReferences(initializer.dartStatement);
        }
      } else if (initializer is InitialSideEffect) {
        // Just call the method implementing the side-effect
        final function = generator._nameForMisc(initializer.effect);
        buffer.writeln('$function();');
      } else if (initializer is InitializeProperty) {
        // We have the property as $property, wrapped in a nullable
        // ZapValue.
        // So write `<type> variable = $variable != null ? $variable.value : <d>`
        final variable = initializer.variable;
        final element = variable.element;

        buffer
          ..write(generator._nameForVar(variable))
          ..write(r' = component.')
          ..write(element.name)
          ..write(' != null ? ')
          ..write(r'component.')
          ..write(element.name)
          ..write('!.value : (');

        final declaration = variable.declaration;
        final defaultExpr =
            declaration is VariableDeclaration ? declaration.initializer : null;
        final isNullable =
            generator.component.typeSystem.isNullable(variable.type);

        if (defaultExpr != null) {
          writeDartWithPatchedReferences(defaultExpr);
        } else if (isNullable) {
          buffer.write('null');
        } else {
          // No initializer and no value set -> error
          final argumentError = prefixIdentifier('ArgumentError');
          buffer.write(
              'throw $argumentError(${dartStringLiteral('Parameter ${element.name} is required!')})');
        }

        buffer.write(');');
      }
    }

    buffer.write('}');
  }
}

class _SubComponentWriter extends _ComponentOrSubcomponentWriter {
  @override
  final ResolvedSubComponent component;

  _SubComponentWriter(
      this.component, Generator generator, GenerationScope classScope)
      : super(generator, classScope);

  @override
  void write() {
    final zapPrefix = generator.imports.zapImport;

    final name = generator._nameForMisc(component);
    buffer.writeln('class $name extends $zapPrefix.Fragment {');

    final parent = component.parent!;
    final parentType = parent is Component
        ? generator.component.componentStateName
        : generator._nameForMisc(parent);

    final needsInitialization = <String>[];

    // Inside subfragments, variables are instiated by the parent component
    // before calling create()
    for (final variable
        in component.scope.declaredVariables.cast<SubcomponentVariable>()) {
      final type = dartTypeToString(variable.type);
      final name = generator._nameForVar(variable);

      switch (variable.kind) {
        case SubcomponentVariableKind.asyncSnapshot:
          buffer.writeln(
              '$type $name = const $zapPrefix.ZapSnapshot.unresolved(); // ${variable.element.name}');
          break;
        case SubcomponentVariableKind.forBlockElement:
        case SubcomponentVariableKind.forBlockIndex:
          needsInitialization.add(name);
          buffer.writeln('$type $name; // ${variable.element.name}');
          break;
      }
    }

    final initializers = [_parentField]
        .followedBy(needsInitialization)
        .map((e) => 'this.$e')
        .join(',');

    buffer
      ..writeln('final $parentType $_parentField;')
      ..writeln('$name($initializers);');

    writeCommonInstanceFields();
    writeBuildMethod();

    buffer.writeln('}');
  }
}

/// A writer for Dart types that automatically adds the right imports for all
/// types.
class _DartTypeWriter extends UnifyingTypeVisitor<void> {
  final Generator generator;
  final StringBuffer buffer;

  _DartTypeWriter(this.generator, this.buffer);

  void _writeSuffix(NullabilitySuffix suffix) {
    switch (suffix) {
      case NullabilitySuffix.question:
        return buffer.write('?');
      case NullabilitySuffix.star:
        return buffer.write('*');
      case NullabilitySuffix.none:
        return;
    }
  }

  void _writeElement(Element element, String name) {
    final library = element.library;
    if (library != null && library != generator.component.resolvedTmpLibrary) {
      final import = generator.imports.importForLibrary(library);
      buffer.write('$import.');
    }

    buffer.write(name);
  }

  @override
  void visitDartType(DartType type) {
    // Unhandled type
  }

  @override
  void visitDynamicType(DynamicType type) {
    buffer.write('dynamic');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitFunctionType(FunctionType type) {
    type.returnType.accept(this);

    buffer.write(' Function');
    final formals = type.typeFormals;
    if (formals.isNotEmpty) {
      buffer.write('<');
      var i = 0;
      for (final arg in formals) {
        if (i != 0) {
          buffer.write(', ');
        }

        buffer.write(arg.name);
        final bound = arg.bound;
        if (bound != null) {
          buffer.write(' extends ');
          bound.accept(this);
        }
        i++;
      }
      buffer.write('>');
    }

    // Write parameters
    buffer.write('(');
    var i = 0;

    String? activeOptionalBlock;

    for (final parameter in type.parameters) {
      if (parameter.isNamed) {
        if (activeOptionalBlock == null) {
          buffer.write('{');
          i = 0; // Don't put a comma before the first named parameter
          activeOptionalBlock = '}';
        }
      } else if (parameter.isOptionalPositional) {
        if (activeOptionalBlock == null) {
          buffer.write('[');
          i = 0; // Don't put a comma before the first optional parameter
          activeOptionalBlock = ']';
        }
      }

      if (i != 0) {
        buffer.write(', ');
      }

      parameter.type.accept(this);
      if (parameter.isNamed) {
        buffer.write(' ${parameter.name}');
      }
      i++;
    }

    if (activeOptionalBlock != null) {
      buffer.write(activeOptionalBlock);
    }

    buffer.write(')');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitInterfaceType(InterfaceType type) {
    final alias = type.alias;
    if (alias != null) {
      _writeElement(alias.element, alias.element.name);
    } else {
      _writeElement(type.element, type.element.name);
    }

    if (type.typeArguments.isNotEmpty) {
      buffer.write('<');
      var i = 0;
      for (final arg in type.typeArguments) {
        if (i != 0) {
          buffer.write(', ');
        }

        arg.accept(this);
        i++;
      }
      buffer.write('>');
    }

    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitInvalidType(InvalidType type) {
    buffer.write('dynamic');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitNeverType(NeverType type) {
    buffer.write('Never');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitRecordType(RecordType type) {
    buffer.write('(');
    var first = true;

    for (final field in type.positionalFields) {
      if (!first) {
        buffer.write(', ');
      }
      first = false;

      field.type.accept(this);
    }

    if (type.namedFields.isNotEmpty) {
      buffer.write('{');
      first = true;
      for (final field in type.namedFields) {
        if (!first) {
          buffer.write(', ');
        }
        first = false;

        field.type.accept(this);
        buffer
          ..write(' ')
          ..write(field.name);
      }
      buffer.write('}');
    }

    buffer.write(')');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitTypeParameterType(TypeParameterType type) {
    buffer.write(type.element.name);
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitVoidType(VoidType type) {
    buffer.write('void');
    _writeSuffix(type.nullabilitySuffix);
  }
}

class _DartSourceRewriter extends GeneralizingAstVisitor<void> {
  final Generator generator;
  final ZapVariableScope? scope;
  final ZapVariableScope rootScope;
  final Map<AstNode, WatchedExpression> watchExpressions;

  final bool patchSelf;

  final int startOffsetInDart;
  int skew = 0;
  String content;

  _DartSourceRewriter(
    this.generator,
    this.scope,
    this.startOffsetInDart,
    this.content,
    this.patchSelf,
    this.watchExpressions,
  ) : rootScope = generator.component.component.scope;

  static String patchDartReferences({
    required AstNode dartCode,
    required Generator generator,
    bool patchSelf = true,
    ComponentOrSubcomponent? component,
    Map<AstNode, WatchedExpression> watchExpressions = const {},
  }) {
    final originalCode = generator.prepareResult.temporaryDartFile.contents
        .substring(dartCode.offset, dartCode.offset + dartCode.length);
    final rewriter = _DartSourceRewriter(generator, component?.scope,
        dartCode.offset, originalCode, patchSelf, watchExpressions);
    dartCode.accept(rewriter);
    return rewriter.content;
  }

  /// Replaces the range from [start] with length [originalLength] in the
  /// [content] string.
  ///
  /// The [skew] value is set accordingly so that [start] can refer to the
  /// original offset before making any changes. This only works when
  /// [_replaceRange] is called with increasing, non-overlapping offsets.
  void _replaceRange(int start, int originalLength, String newContent) {
    var actualStart = skew + start - startOffsetInDart;

    content = content.replaceRange(
        actualStart, actualStart + originalLength, newContent);
    skew += newContent.length - originalLength;
  }

  void _replaceNode(SyntacticEntity node, String newContent) {
    _replaceRange(node.offset, node.length, newContent);
  }

  BaseZapVariable? _variableFor(Element? element) {
    ZapVariableScope? scope = this.scope;

    while (scope != null) {
      final variable =
          scope.declaredVariables.firstWhereOrNull((v) => v.element == element);
      if (variable != null) {
        return variable;
      }

      scope = scope.parent;
    }

    return null;
  }

  /// Writes Dart code necessary to access variables defined in the
  /// [targetScope].
  ///
  /// When the [targetScope] is the current [scope], the result will be empty.
  /// When its a parent of the current scope, the result would be `parent.`.
  /// For scopes further up, `parent.` would be repeated.
  String _prefixFor(ZapVariableScope targetScope, {bool trailingDot = true}) {
    var current = scope;
    if (current == null) {
      return trailingDot ? 'this.' : '';
    }

    final result = StringBuffer();

    while (current != targetScope) {
      if (result.isNotEmpty) {
        result.write('.');
      }

      result.write(_parentField);
      current = current!.parent!;
    }

    if (trailingDot && result.isNotEmpty) {
      result.write('.');
    }

    return result.toString();
  }

  String invalidateExpression(String bitmaskCode) {
    if (scope == rootScope) {
      return '\$invalidate($bitmaskCode);';
    } else {
      final prefix = _prefixFor(rootScope);
      return '$prefix\$invalidateSubcomponent(this, $bitmaskCode);';
    }
  }

  void _visitCompoundAssignmentExpression(CompoundAssignmentExpression node) {
    final target = node.writeElement;
    final variable = _variableFor(target);
    final notifyUpdate = variable != null && variable.needsUpdateTracking;

    // Wrap the assignment in an $invalidateAssign block so that it can still
    // be used as an expression while also scheduling a node update!
    if (notifyUpdate) {
      if (scope == rootScope) {
        _replaceRange(node.offset, 0, '\$invalidateAssign(');
      } else {
        final prefix = _prefixFor(rootScope);
        _replaceRange(
            node.offset, 0, '$prefix.\$invalidateAssignSubcomponent(this,');
      }
    }

    node.visitChildren(this);

    if (notifyUpdate) {
      _replaceRange(node.offset + node.length, 0, ')');
    }
  }

  /// For syntactic constructions of the form `x.y`, where `x` is an import
  /// prefix identifier, rewrites the construction to just `y`. Visiting the
  /// simple identifier will add the necessary prefix.
  void _handleTarget(Expression? left, Token? operator) {
    if (left is SimpleIdentifier) {
      final target = left.staticElement;
      if (target is PrefixElement && operator != null) {
        _replaceNode(left, '');
        _replaceNode(operator, '');
      }
    }
  }

  void _patchIdentifier(SyntacticEntity entity, Element? target) {
    final targetLibrary = target?.library;

    if (targetLibrary != generator.component.resolvedTmpLibrary) {
      // Referencing an element from an import, add necessary import prefix.
      final isTopLevel = targetLibrary != null &&
          targetLibrary.topLevelElements.contains(target);

      if (isTopLevel) {
        final importPrefix = generator.imports.importForLibrary(targetLibrary);
        _replaceRange(entity.offset, 0, '$importPrefix.');
      } else if (target is ExecutableElement &&
          !target.isStatic &&
          target.enclosingElement is ExtensionElement) {
        final extension = target.enclosingElement as ExtensionElement;
        final name = extension.name;

        // Target is from an extension, import that extension without an alias
        // so that the extension invocation continues to work.
        if (name != null) {
          generator.imports.importWithoutAlias(extension.library, name);
        }
      }
      return;
    }

    final variable = _variableFor(target);

    if (variable is SelfReference) {
      // Inside the main component, we can replace `self` with `this`. In
      // inner components, we have to walk the parent.

      if (patchSelf) {
        if (rootScope == scope) {
          _replaceNode(entity, 'this');
        } else {
          final prefix = _prefixFor(rootScope, trailingDot: false);
          _replaceNode(entity, prefix);
        }
      }
    } else if (target is FunctionElement &&
        generator.component.userDefinedFunctions.contains(target)) {
      final newName = generator._nameForFunction(target);
      final prefix = _prefixFor(rootScope);

      _replaceNode(entity, '$prefix$newName');
    } else if (variable != null) {
      final prefix = _prefixFor(variable.scope);
      final name = generator._nameForVar(variable);

      final replacement = '$prefix$name /* ${target?.name} */';
      _replaceNode(entity, replacement);
    }
  }

  @override
  void visitFunctionDeclaration(FunctionDeclaration node) {
    node.returnType?.accept(this);
    _patchIdentifier(node.name, node.declaredElement);
    node.functionExpression.accept(this);
  }

  @override
  void visitMethodInvocation(MethodInvocation node) {
    if (isWatchFunctionFromDslLibrary(node.methodName)) {
      // Replace `watch(foo) with `$watchImpl(foo, updateFlag: 123)`
      final prefix = _prefixFor(rootScope);
      final resolvedWatch =
          watchExpressions[node.argumentList.arguments.single];

      if (resolvedWatch != null) {
        _replaceNode(node.methodName, '$prefix\$watchImpl');

        visitNode(node.argumentList.arguments.single);

        final updateFlag = resolvedWatch.updateSlot!;
        _replaceNode(node.argumentList.rightParenthesis, ', $updateFlag)');

        return;
      }
    }

    _handleTarget(node.target, node.operator);
    super.visitMethodInvocation(node);
  }

  @override
  void visitNode(AstNode node) {
    if (watchExpressions.containsKey(node)) {
      final target = watchExpressions[node]!.expression;
      final getterName = generator._nameForMisc(target);

      _replaceNode(node, '${_prefixFor(target.scope)}$getterName');
    } else {
      super.visitNode(node);
    }
  }

  @override
  void visitInterpolationExpression(InterpolationExpression node) {
    if (node.expression case final SimpleIdentifier expression) {
      // Interpolated variables must be wrapped in braces since the
      // replacement identifier will have `$` in the name.
      //
      // For example, '$localVariable' becomes '${_$v1 /* localVariable */}'.
      final missingBraces = node.rightBracket == null;
      if (missingBraces) {
        _replaceRange(node.leftBracket.end, 0, '{');
      }
      _patchIdentifier(expression, expression.staticElement);
      if (missingBraces) {
        _replaceRange(expression.end, 0, '}');
      }
    } else {
      super.visitInterpolationExpression(node);
    }
  }

  @override
  void visitAssignmentExpression(AssignmentExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitPrefixExpression(PrefixExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitPrefixedIdentifier(PrefixedIdentifier node) {
    final targetOfPrefix = node.prefix.staticElement;
    if (targetOfPrefix is PrefixElement) {
      _handleTarget(node.prefix, node.period);
      visitSimpleIdentifier(node.identifier);
    } else {
      super.visitPrefixedIdentifier(node);
    }
  }

  @override
  void visitPostfixExpression(PostfixExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitNamedType(NamedType node) {
    final prefix = node.importPrefix;
    if (prefix != null) {
      // patchIdentifier will add the right identifier if needed.
      _replaceNode(prefix, '');
    }
    _patchIdentifier(node.name2, node.element);

    node.typeArguments?.accept(this);
  }

  @override
  void visitSimpleIdentifier(SimpleIdentifier node) {
    _patchIdentifier(node, node.staticElement);
  }
}
